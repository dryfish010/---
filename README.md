## 利用基因演算發優化工作流程& 系統     



###  一、系統描述:
此系統運用基因演算法來優化排程，並進一步擴展其功能，以構建更完整的排程系統為目標。除了核心排程算法，本系統融入時間因素與使用者介面，以提升可操作性和實用性。
主要功能包括：

•	**生成甘特圖**，直觀呈現機器處理順序，提供視覺化的工作流展示。

•	**支援多線程處理**，使機器能同時執行多項工作，提升排程效率。

•	**納入機器處理時間差異**，確保排程能根據各設備的特性進行最佳化調整。

•	**針對工作期限**，考量遲交影響，強化系統對現實工作環境的適應能力。

透過這些強化功能，本系統能提供更靈活且貼近實際運作的排程解決方案，提升工廠或企業在生產計畫上的精準度與效率。
問題維度:舊問題，舊解法

🛠️ 環境需求
- Python 3.8+

- matplotlib

- collections、datetime、base64 等標準庫


### 二、系統內容:

入口畫面:

![image](https://github.com/user-attachments/assets/39438aeb-01c9-4c27-b1c3-258fe7ccfbbc)


#### 系統輸入:


**機器輸入:**
1.	可輸入名稱、處理時間、最大容量
2.	最大容量:機器一次能處理幾個工作
3.	需要輸入一個及以上的機器才能新增工作

![image](https://github.com/user-attachments/assets/f775b7f1-c56c-4c76-b4e2-0d62bf3d1915)



 工作輸入:
1.	輸入工作數量後始得開始輸入工作內容，工作數量需要大於二
2.	輸入處理天數及加工數量，便能開始選定機器名稱
   
![image](https://github.com/user-attachments/assets/6ed27d4e-ee7f-47c7-a732-97c8f1f6e8ae)

#### 系統輸出:

每個工作的步驟及處理的時間
 
**甘特圖**

 ![image](https://github.com/user-attachments/assets/977b7fdb-0c32-4deb-a194-aa05905b0c60)
 

**收斂圖**

 ![image](https://github.com/user-attachments/assets/fdb1353e-d9fd-45bc-b593-70c8172763f1)

###  三、系統架構


| 模組     | 說明                                                                       |
| ------ | ------------------------------------------------------------------------ |
| 遺傳演算法  | 負責搜尋最佳機器順序，最小化工作時間、遲交懲罰與機器負載                                             |
| 適應度評估  | 考慮以下 4 種因素來評分：<br>1️⃣ 步數數量<br>2️⃣ 工作總處理時間<br>3️⃣ 超過截止時間的懲罰<br>4️⃣ 機器超載懲罰 |
| 排程排序策略 | 根據每個工作的總適應度分數高低，優先排定高分的工作順序                                              |
| 可視化    | 使用 matplotlib 畫出甘特圖（Gantt chart），支援多容量顯示、不同工作顏色、機台分層等功能                  |


1.	系統流程圖:
   
![image](https://github.com/user-attachments/assets/c1c4f057-468f-4678-b926-c79d362b2de7)

i.	前端html+ js + css:

用戶輸入機器:資訊包含名稱、處理時間(依小時計算)、最大容量，每次點及新增機器的按鈕，來動態產生輸入欄位。

用戶輸入工作數量:當用戶開始輸入工作數量會檢查輸入的機器是否大於一個也會同步檢查工作數量是否大於二，以利後端模型的運作，輸入處理的總時長及機器數量後系統會生成對應的工作數量，使用者可以透過選單選取對應的機器。輸入完成後用會將內容傳到後端坐處理

ii.	後端flask
簡略流程圖:

![image](https://github.com/user-attachments/assets/8a011aee-ca75-4f8a-a58b-6c57d9b78730)



#### 基因演算法

#### 一、系統分析圖:
-------------------	
 ![image](https://github.com/user-attachments/assets/1450967f-e4da-4328-a87e-0fdac68935b0)

#### 二、程式細節與實驗:
-------------------	
	基本流程為 初始化、評估、選擇、交配、突變，首先需要先設定族群大小、跌代次數及突變率
	族群大小:決定初始族群的基因數量
	跌代次數:需要進行多少次的完整輪迴(選擇->交配->突變->評估)
	突變率:突變的機率，用來增加多樣性
  

大略流程圖:
 ![image](https://github.com/user-attachments/assets/b99eb79c-1bdb-43d5-902f-cfedf6353fbc)

1.	initialPop 初始化族群:
在隨機產生初始族群時，原先的規劃是將工作站 R 固定為第一個位置，其餘八個工作站隨機排列，以期提升搜尋效率並降低所需的迭代次數。然而，在實際測試後發現，若不將 R 固定於開頭，讓所有工作站自由排列，反而能在接近的迭代次數下獲得更優的解，因此最終採用不固定 R 的設計，以提高演算法的彈性與解的品質。
 
|在程式碼中固定R	|在程式碼中無固定R|
 
|![image](https://github.com/user-attachments/assets/7035e699-f8c3-4b64-a9d0-fbad9e745353)|![image](https://github.com/user-attachments/assets/578743a2-7f22-4e12-ac97-41d348208bd2)
|

 

2.	StepCA 計算步數: 
由於本題的效率評估以「總步數」為主要依據，因此在前處理階段，為了方便計算與操作，我們將原始的工作站名稱轉換為對應的數字編碼。接著，在流程中記錄每一步驟的順序與其所橫跨的工作站數，進而計算出該路徑的總步數。最後，將總步數作為輸入傳入適應度函數中進行評估。考量到 StepCA 函數在程式中需被多個模組或函式調用，因此將其與適應度函數分開實作  
 
3.	SelectGA:使用競賽選擇
常見的父代選擇方法包括競賽選擇與輪盤選擇。在本次實作中發現，輪盤選擇法因為對適應度差異較小的個體辨識度不高，容易選到表現較差的個體，導致解的品質不穩定，且收斂曲線波動較大。此外，輪盤選擇通常需要更多的世代數來逼近全域最優解，因此在本題中不適用。相較之下，競賽選擇法具備較高的選擇壓力，能更穩定地選出表現較佳的個體，有助於加快收斂速度與提升整體解的品質，因此本次採用競賽選擇法作為父代選擇策略。 
 
輪盤選擇法	          競賽選擇法

  ![image](https://github.com/user-attachments/assets/a8c88c99-48fa-41c2-a20a-91aa184dacd3)![image](https://github.com/user-attachments/assets/9aad4eac-ccd6-4b34-95c2-29618a6f0e85)


	 
4.	Crossover 交配
順序型基因的交配策略，透過隨機選取父代中一段基因（通常是連續的一段子序列），將其直接複製到子代的對應位置。接著，從另一個父代中，依照其基因出現的順序，跳過已經複製的基因，將剩餘的基因依序填入子代中尚未指定的位置。這樣的設計確保了子代中的基因不會重複，且保留了父代的部分結構與順序。
 
 

5.	Mutate 突變:
為了避免基因演算法在演化過程中陷入局部最優解而喪失多樣性，突變機制被引入以隨機打亂基因序列。其中，常見的突變方法包括 倒置（Inversion）、交換（Swap） 以及 打亂（Scramble）。最初本專案使用的是交換法進行突變處理，但在實驗比較三種方法後發現，Scramble mutation 在多次測試中能以較少的迭代次數收斂至最佳解，因此最終採用 Scramble 作為本演算法的突變策略。 
 
swap

![image](https://github.com/user-attachments/assets/4707c233-03c8-4534-acf0-cc072adf3764)

 
Inversion

 ![image](https://github.com/user-attachments/assets/8b76be3e-9eeb-458a-b942-9130b0e1bba1)

Scramble

 ![image](https://github.com/user-attachments/assets/c4c77a56-8743-4184-97a9-1e7040ba6138)


6.	NextGA產生子代: 
在每一代中，演算法會隨機挑選兩個父代個體，透過交配（crossover 函數）產生出一個子代。接著，根據預設的突變率判斷是否對該子代進行突變操作(mutation 函數)。最後，產生出的子代將被加入到新一代的族群中，作為後續演化的基礎。
 
整合演算法中的各函數:	處理輸出
	
 	 	
7.	壓力測試

![image](https://github.com/user-attachments/assets/a1cc212a-6abd-4d84-9ca8-bada7e0b98db)

 	 

五、結果分析:
 
	
以此範例為例，最佳步數為 48，對應適應值達 73%。當族群大小（PopSize）設定為 80 以上時，演算法能穩定地在 20 次以內完成收斂，平均僅需 8 次跌代即可找到最佳解。整體平均處理時間可控制在 0.1 秒內。
六、結論與發現
在實作過程中，發現部分初始假設可能限制了演算法表現，導致無法找到更佳解：
1.	最初在程式中預設工作流程必須以 R 為開頭（即將 R 固定在染色體首位），然而在後續測試中發現，若不強制將 R 放在第一位，反而能獲得更優的結果。儘管如此，最終找到的解中仍普遍以 R 為起始站點，顯示 R 作為起點具備實際意義，但不應在演算法初期進行硬性限制，否則可能排除潛在的更佳組合。這樣的差異雖然明顯，仍有待進一步探究其內部邏輯與解空間變化之關聯性。
2.	另一項假設為「變異率（Mutation Rate）會對結果產生顯著影響」。然而經實測後發現，在多組變異率設定下，演算法表現差異不大。即使使用較高的變異率，也未出現預期中的收斂圖混亂或局部最小陷阱等情形，顯示本問題的收斂性對變異率具有一定的容錯性。
   
 	 

### 適應度計算:
```
def efficiency(schedule, jobs, job_deadlines, machine_times, machine_capacity):
    # 評估該 machine 排列下，所有 job 的平均成本
```

1.	**步數計算 (total_steps)**:衡量機器調度的連續性，確保工作步驟排列合理，減少無謂的跳躍。
2.	**總處理時間 (total_time)**:根據機器的處理時間進行累計，確保整體排程時間最優化。
3.	**遲交懲罰 (total_late_penalty)**:若工作完成時間超過指定期限，則施加懲罰，以鼓勵更有效的規劃。
4.	**機器負載 (machine_overload_penalty)**:若機器的使用超過其最大承載能力，則施加懲罰，以避免過度使用特定機器。
5.	函式回傳一個適應度分數，以 倒數形式 (1 / (總懲罰 + 調度成本))，讓演算法能夠最大化此值來找到最佳解。這確保機器排程不僅符合時間與步驟的最佳化，也避免了過度負載的問題。
6.	可計算單個工作之間的步數及多個工作之間

```
def calculate_job_fitness(jobs, job_deadlines, machine_times, machine_capacity, best_step_sequence):
    # 給每個 job 獨立評分（以最佳解的排序為基礎）

```
1. 基於適應度評分單個工作
2. 評分越高越早安排(避免延遲)

### 甘特圖繪製:


#### 四、問題:
在撰寫程式當中遇到了一些技術上的問題，些克服了但是還是有無法克服的問題:

1 .Matplotlib 問題（已解決）：由於 Matplotlib 產生的圖像無法直接傳送至前端，因此需先轉換為 Base64 編碼格式，以便嵌入網頁或 API 回應。一般情況下，Matplotlib 會自動開啟 GUI 介面，但在網頁環境中可能導致錯誤。因此，使用 "Agg" 作為渲染後端，以切換至無 GUI 模式，確保圖像能順利處理並傳輸。這樣能有效解決網頁應用中的圖像顯示問題，提升系統穩定性。

2. 系統無回應（未解決）：在進行排程後，若再次執行排程，後端存在一定機率發生崩潰，導致系統無法回應並需重新啟動。

