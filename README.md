## 利用基因演算發優化工作流程& 系統           


一、問題描述:
-------------------	
	目標
本問題中共有八個工作站：R、A、B、C、D、E、F、S。目標為針對每項工作，找出其經過各工作站的最佳順序，以達到總體流程的最少步數
輸入:
1.	工作的個數(整數)
2.	每個共作所需經過的工作站，以
數字表示，並以”，” 坐間格
3.	此程式沒有防呆機制
	本篇將以以下為例:
1.	R,A,B,D,C,F,S
2.	R,B,D,C,A,S
3.	R,E,F,B,A,C,D,S
4.	R,F,A,C,D,S
5.	R,C,A,D,S
6.	最小步數為35 步，並將工作步數優化至69% 效率，步數為51 步或是更低
輸出:
1.	優化後的站點順序
2.	最佳步數
3.	適應值
4.	收斂圖
5.	找到最優解的跌代次數
所需系統:
Python
flask

動機:
在進行作業二的初期，雖然完成了基本版本的實作。但是在測試與觀察執行結果的過程中，我發現某些設計或參數設定仍有優化空間，例如程式的效率、結果的穩定性。因此，進一步思考並著手改善這些部分，以提升整體表現與執行品質。
系統為其中延伸的



二、系統分析圖:
-------------------	
 ![image](https://github.com/user-attachments/assets/1450967f-e4da-4328-a87e-0fdac68935b0)

三、程式撰寫過程:
-------------------	
	基本流程為 初始化、評估、選擇、交配、突變，首先需要先設定族群大小、跌代次數及突變率
	族群大小:決定初始族群的基因數量
	跌代次數:需要進行多少次的完整輪迴(選擇->交配->突變->評估)
	突變率:突變的機率，用來增加多樣性
  

大略流程圖:
 ![image](https://github.com/user-attachments/assets/b99eb79c-1bdb-43d5-902f-cfedf6353fbc)

1.	initialPop 初始化族群:
在隨機產生初始族群時，原先的規劃是將工作站 R 固定為第一個位置，其餘八個工作站隨機排列，以期提升搜尋效率並降低所需的迭代次數。然而，在實際測試後發現，若不將 R 固定於開頭，讓所有工作站自由排列，反而能在接近的迭代次數下獲得更優的解，因此最終採用不固定 R 的設計，以提高演算法的彈性與解的品質。
 
|在程式碼中固定R	|在程式碼中無固定R|
 
|![image](https://github.com/user-attachments/assets/7035e699-f8c3-4b64-a9d0-fbad9e745353)|![image](https://github.com/user-attachments/assets/578743a2-7f22-4e12-ac97-41d348208bd2)
|

 

2.	StepCA 計算步數: 
由於本題的效率評估以「總步數」為主要依據，因此在前處理階段，為了方便計算與操作，我們將原始的工作站名稱轉換為對應的數字編碼。接著，在流程中記錄每一步驟的順序與其所橫跨的工作站數，進而計算出該路徑的總步數。最後，將總步數作為輸入傳入適應度函數中進行評估。考量到 StepCA 函數在程式中需被多個模組或函式調用，因此將其與適應度函數分開實作  
 
3.	SelectGA:使用競賽選擇
常見的父代選擇方法包括競賽選擇與輪盤選擇。在本次實作中發現，輪盤選擇法因為對適應度差異較小的個體辨識度不高，容易選到表現較差的個體，導致解的品質不穩定，且收斂曲線波動較大。此外，輪盤選擇通常需要更多的世代數來逼近全域最優解，因此在本題中不適用。相較之下，競賽選擇法具備較高的選擇壓力，能更穩定地選出表現較佳的個體，有助於加快收斂速度與提升整體解的品質，因此本次採用競賽選擇法作為父代選擇策略。 
 
輪盤選擇法	競賽選擇法
  
	 
4.	Crossover 交配
順序型基因的交配策略，透過隨機選取父代中一段基因（通常是連續的一段子序列），將其直接複製到子代的對應位置。接著，從另一個父代中，依照其基因出現的順序，跳過已經複製的基因，將剩餘的基因依序填入子代中尚未指定的位置。這樣的設計確保了子代中的基因不會重複，且保留了父代的部分結構與順序。
 
 








5.	Mutate 突變:
為了避免基因演算法在演化過程中陷入局部最優解而喪失多樣性，突變機制被引入以隨機打亂基因序列。其中，常見的突變方法包括 倒置（Inversion）、交換（Swap） 以及 打亂（Scramble）。最初本專案使用的是交換法進行突變處理，但在實驗比較三種方法後發現，Scramble mutation 在多次測試中能以較少的迭代次數收斂至最佳解，因此最終採用 Scramble 作為本演算法的突變策略。 
 
swap
 
Inversion
 
Scramble
 

6.	NextGA產生子代: 
在每一代中，演算法會隨機挑選兩個父代個體，透過交配（crossover 函數）產生出一個子代。接著，根據預設的突變率判斷是否對該子代進行突變操作(mutation 函數)。最後，產生出的子代將被加入到新一代的族群中，作為後續演化的基礎。
 
整合演算法中的各函數:	處理輸出
	
 	 









	
四、	壓力測試
變異率為0.8	變異率為0.5
 	 
變異率為0.125	變異率為0.001
 	 
	Popsize=100	Popsize =1000
 	 
Popsize=50 	Popsieze=80
 	 




五、結果分析:
收斂圖	結果
 	 
	
以此範例為例，最佳步數為 48，對應適應值達 73%。當族群大小（PopSize）設定為 80 以上時，演算法能穩定地在 20 次以內完成收斂，平均僅需 8 次跌代即可找到最佳解。整體平均處理時間可控制在 0.1 秒內。
六、結論與發現
在實作過程中，發現部分初始假設可能限制了演算法表現，導致無法找到更佳解：
1.	最初在程式中預設工作流程必須以 R 為開頭（即將 R 固定在染色體首位），然而在後續測試中發現，若不強制將 R 放在第一位，反而能獲得更優的結果。儘管如此，最終找到的解中仍普遍以 R 為起始站點，顯示 R 作為起點具備實際意義，但不應在演算法初期進行硬性限制，否則可能排除潛在的更佳組合。這樣的差異雖然明顯，仍有待進一步探究其內部邏輯與解空間變化之關聯性。
2.	另一項假設為「變異率（Mutation Rate）會對結果產生顯著影響」。然而經實測後發現，在多組變異率設定下，演算法表現差異不大。即使使用較高的變異率，也未出現預期中的收斂圖混亂或局部最小陷阱等情形，顯示本問題的收斂性對變異率具有一定的容錯性。
